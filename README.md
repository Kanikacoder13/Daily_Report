# Daily Report
## Training day :- 01
I am **Kanika**. Today was my first day of summer training in the **Computer Science Department(Parent branch)** . I was very excited about this training . Firstly there was an **orientation program** conducted for us in the **auditorium** . Here , I interacted with **Dr. Priyanka** who is professor in **Computer Scienec department** . She gave all the necessary information that was required and also welcomed all the students who are going to be part of the parent branch . She told us about socities , attendance creteria and many other things . Then , I interacted with **Head of Department, Dr. Kiran Jyoti** along with all the students . She also introduced a new scheme for **2024 year onwards students**. After this valuable interaction , all the students shifted to their respective labs . In the lab , our teacher explained the syllabus of this training that all the students will study in further days . Then she said that first day we will discuss about **Linux**.
Firstly i learned about **Linux** & **its importance** then why most of the **companies** & **coders** use **Linux** over **Windows** ? Following are the reasons behind it :- 
- Linux is **more secure** due to its permission-based system and fewer malware targets than windows.
- Linux is **open source** , so it can be easily available.
- Linux is **free** , while windows required paid license.
- Linux has large community.

---
  
  ### Difference between linux and window
  | Feature | Linux | Window |
  |---------|-------|--------|
  |   Type	|Open-source OS	|Proprietary OS|
  |  Cost	  | Free to use	  |Paid (license required)|
  |Security	| More secure,less virus-prone	|More vulnerable to malware|
  |Customization |	Highly customizable	| Limited customization|
  |Command Line	|Command line used often (Terminal)|Mostly GUI-based| 
  |Performance	|Lightweight, works well on older systems	|Requires more system resources|
  |User Interface |Depends on distro (e.g., Ubuntu, Fedora)|Standard and consistent UI|
  |Support for Software|Limited for some commercial software|Widely supported software (e.g., MS Office)|
  |Best for |	Developers, programmers, servers|General users, gamers,¬†businesses|

  ---
  ### Uses of linux :-
  - Servers
  - Programming
  - Cybersecurity
  - Education
  - Cloud Computing
  - Networking
---
Here are **career opportunities with Linux** in short points:

1. **Linux System Administrator** ‚Äì Manage Linux servers and systems.
2. **DevOps Engineer** ‚Äì Automate deployment and infrastructure.
3. **Cloud Engineer** ‚Äì Work with AWS, Azure, GCP using Linux servers.
4. **Cybersecurity Analyst** ‚Äì Use Linux for ethical hacking and security.
5. **Software Developer** ‚Äì Develop apps and tools on Linux platforms.
6. **Linux Support Engineer** ‚Äì Troubleshoot Linux systems and provide tech support.
7. **Embedded Systems Engineer** ‚Äì Build Linux-based systems for IoT, robotics.
8. **Data Scientist** ‚Äì Use Linux for big data processing and analysis.
9. **Open Source Contributor** ‚Äì Contribute to Linux and open-source projects.
10. **IT Trainer** ‚Äì Teach Linux skills and prepare others for certifications.
----
  ### Installation of linux
  - Step 1: Download and Install VirtualBox
  - Step 2: Download Microsoft Visual C++ Redistributable
  - Step 3: Download Ubuntu ISO
  - Step 4: Create a Virtual Machine and Install Ubuntu

  ### Resources

1.  [Download Oracle Virtual Box](https://www.virtualbox.org)

2.  [Download Latest Visual C++ Redistributable](https://learn.microsoft.com/en-US/cpp/windows/latest-supported-vc-redist)

3.  [Download Ubuntu](https://tinyurl.com/csegndec)

  
---

### Study of Product-based company and Service-based comapany

- **Product-based Company**:- A company that builds and sells its **own products** like software,apps, or devices. **E.g.**:- Google , Microsoft.

- **Service-based Company**:- A comapny that provides **services to other companies** like software development,support or consulting. **E.g.**:- TCS , Infosys.

---
## Booting and its types 
I have also learned about booting and types-

### üñ•Ô∏è What is Booting?

**Booting** is the process of starting a computer.
When you switch on your computer, the system loads the operating system (like Windows or Linux) from the hard drive into the RAM (memory), so you can use the computer.

### üîÅ Booting Process :

1. **Power On** ‚Äì You turn on the computer.
2. **POST (Power-On Self-Test)** ‚Äì System checks hardware (RAM, keyboard, etc.).
3. **BIOS/UEFI Loads** ‚Äì Basic system firmware starts.
4. **Boot Loader Activated** ‚Äì BIOS/UEFI finds and runs the boot loader.
5. **OS Loading** ‚Äì Boot loader loads the operating system into RAM.
6. **System Ready** ‚Äì Operating system starts, and the computer is ready to use.

---

### üßæ Types of Booting:

üîÑ 1. **Cold Booting (Hard Booting):**

‚û°Ô∏è **Meaning**: Starting the computer when it is completely turned off.

‚û°Ô∏è **Example**: You press the **power button** to turn on your computer after it was shut down ‚Äì that's **cold booting**.

üîÅ 2. **Warm Booting (Soft Booting)**:

‚û°Ô∏è **Meaning**: Restarting the computer without turning off the power.

‚û°Ô∏è **Example**: You press **Ctrl + Alt + Del** or click **Restart** on Windows ‚Äì that's **warm booting**.

üîß 3. **Dual Booting**:

‚û°Ô∏è **Meaning**: Having **two operating systems** installed and choosing one to run.

‚û°Ô∏è **Example**: Your laptop has Windows and Linux installed. At startup, you choose which one to use.

‚òÅÔ∏è 4. **Network Booting (PXE Booting)**:

‚û°Ô∏è **Meaning**: Booting a computer from a **network server** instead of **local storage**.

‚û°Ô∏è **Example**: In a computer lab, systems boot from the college server using a LAN cable.

---

## Training Day :- 02
---
Day **two** of the **summer training program** picked up right where we left off , diving deeper into the concepts introduced yesterday. It brought with a fresh set of challenges and exciting new information . The instructor continued to provide insightful explanations making complex concepts easy to grasp . It was a productive day thaT further fueled my enthusiasm for the rest of the training .

---
## Structure of Linux shell

![alt text](Linuxshell.png)

----

### Study of Kernel
The kernel is the core part of an operating system.

It manages the communication between hardware and software.

Also, it manages the following resources of the linux system :-

- Memory management
- File manangement
- Device management
- Process management
- I/O management etc

-----------------------------------

### Study of Shell

The shell is a program that acts as an interface between the user and the operating system.

It takes user commands and tells the operating system to perform tasks.

It lets you type commands to tell the computer what to do , like opening files , mananging programs.
 
 ### Types of Shell

Shells are mainly divided into two categories:

 **1. Command-Line Interface (CLI) Shells**

User interacts by typing commands

Fast and powerful for developers and system admins

Examples (Types of CLI Shells):

|Shell Name	|          Description                 |
|-----------|--------------------------------------|
|     sh	  |Bourne Shell (original Unix shell)    |
|    bash   |	Bourne Again Shell (most popular)    |
|   csh     |	      C Shell (C-like syntax)        |
|    ksh    |	   Korn Shell (advanced features)    |
|    zsh    |Z Shell (user-friendly & customizable)|
|-----------|--------------------------------------|

### üêö What is **Bash**?

**Bash** stands for **Bourne Again SHell**.
It is a **command-line shell** used in **Linux** and **Unix-based systems** to **interact with the operating system**.

---

### üîπ **Simple Definition:**

> **Bash** is a program that lets you **type commands** to control your computer without using the mouse.

---

### ‚úÖ **Key Features:**

* Used to **run commands** like creating files, copying, moving, or deleting.
* Supports **scripting**, so you can **automate tasks** with `.sh` files.
* Built-in on **Linux**, **macOS**, and available for **Windows** (via WSL or Git Bash).

---

### üß† **Example Bash Commands:**

```bash
ls       # list files
cd       # change directory
mkdir    # make a new folder
rm       # remove files/folders
echo     # print text
```

---

### üìú **Example of a Bash Script:**

```bash
#!/bin/bash
echo "Hello, Kanika!"
mkdir my_folder
cd my_folder
touch file.txt
```

---

### üîÅ **Why Bash is Important:**

* Core part of **Linux system administration**.
* Helps in **automation** (via shell scripting).
* Essential for **DevOps**, **ethical hacking**, **software development**, and more.

---

Let me know if you want a **Bash cheat sheet** or beginner guide PDF!

**2. Graphical User Interface (GUI) Shells**

User interacts using windows, icons, and buttons

Easy for beginners

**Example** : GNOME, KDE (on Linux)

----

## üìÅ Linux File System Structure 

A file system structure is the way an operating system organizes and manages data (files and folders) on a storage device like a hard disk or SSD.

It defines:

   * How files are stored

   * How folders (directories) are arranged

   * How the system keeps track of file locations and permissions

The Linux file system is organized **like a tree**, starting from the **root** directory `/`.  
All files and folders are inside this root, even if they are on different drives.

![alt text](struct.png)

The file system structure is like a **digital cabinet** that helps the OS and users **to keep data organized and easy to access**

### üå≥ Main Folders in Linux File System

| Directory | Meaning |
|-----------|---------|
| `/`       | **Root** ‚Äì Starting point of the file system |
| `/bin`    | Essential **binaries** (like `ls`, `cp`, etc.) |
| `/boot`   | Files needed to **boot** the system |
| `/etc`    | System **configuration** files |
| `/home`   | Personal folders for **users** (like `/home/kanika`) |
| `/lib`    | Shared **libraries** for programs |
| `/media`  | Used to mount **USB drives, CDs** etc. |
| `/opt`    | **Optional software** packages |
| `/root`   | **Home directory** of the root user |
| `/sbin`   | System **admin commands** |
| `/tmp`    | Temporary files (auto-deleted) |
| `/usr`    | User-related programs and data |
| `/var`    | Variable data (like **logs**, mails) |

---

#### üìå Key Points

- The top-level directory is `/` (called **root**).
- Everything is organized under `/` like branches of a tree.
- Linux does **not** use drive letters like Windows (C:, D:) ‚Äî everything is part of the same tree.

  -----
## üíΩ What is Slash Full Disk in Linux?

In Linux, when someone says **"slash full disk"** or **"/ is full"**, it means the **root directory (`/`)** has **no free space left**.

---

### ‚úÖ What is `/` (Slash) in Linux?

- `/` is called the **root directory**.
- It is the **starting point** of the entire Linux file system.
- All other folders like `/home`, `/etc`, `/bin`, etc., exist inside `/`.

---

### üö® What Does "Slash Full Disk" Mean?

- The **main partition** of Linux (where it‚Äôs installed) is **completely full**.
- No space is available to save files, install software, or update the system.

---

### ‚ö†Ô∏è Why Is It a Problem?

- System becomes **slow** or may **crash**.
- You can‚Äôt install or update software.
- Some apps and services may stop working.

---

### üõ†Ô∏è How to Check If `/` Is Full?
           df -h /
          
üìå Quick Summary
|  Term  | Meaning |
|--------|---------|
| / (Slash)|	Root directory (main Linux filesystem)|
|Slash Full Disk|	The root disk is full ‚Äì no free space left|
## üñ•Ô∏è Basic Shell Commands in Linux (With Syntax)

| Command | Description | Syntax | Example |
|--------|-------------|--------|---------|
| `ls` | Lists files and folders | `ls [options]` | `ls -l` |
| `cd` | Changes directory | `cd [directory]` | `cd /home/user` |
| `mkdir` | Creates a new folder | `mkdir [folder_name]` | `mkdir myfolder` |
| `rmdir` | Removes an empty folder | `rmdir [folder_name]` | `rmdir myfolder` |
| `touch` | Creates a new empty file | `touch [file_name]` | `touch file.txt` |
| `rm` | Removes files or folders | `rm [file/folder]` | `rm file.txt` |
| `cp` | Copies files/folders | `cp [source] [destination]` | `cp file.txt /home/user/` |
| `mv` | Moves or renames files/folders | `mv [source] [destination]` | `mv file.txt newname.txt` |
| `cat` | Displays contents of a file | `cat [file_name]` | `cat file.txt` |
| `whatis` | Gives a one-line description of a command | `whatis [command]` | `whatis ls` |
| `whereis` | Shows location of binary, source, and man page | `whereis [command]` | `whereis gcc` |
| `clear` | Clears the terminal screen | `clear` | `clear` |
| `man` | Shows manual/help for a command | `man [command]` | `man ls` |
| `exit` | Closes the terminal session | `exit` | `exit` |
| `pwd` | Shows current directory path | `pwd` | `pwd` |

**Point to remember** : 
    
    **cd ..** (moves up one directory that means it will take out of that box and into the box it was placed inside)
  
**Example**:
  
  If you are currently in: /home/user/documents/reports/
  Typing cd .. will take you to: /home/user/documents/

---

![alt text](com1.jpg)

![alt text](com2.jpg)

**nano** command :

   - A text editor in linux
   - Beginner-friendly
   - Simple and clear

*Important shortcut keys*:

 - Ctrl + O ‚Üí Save the file (O for Output)
 - Ctrl + X ‚Üí Exit
 - Ctrl + K ‚Üí Cut a line
 - Ctrl + U ‚Üí Paste

**vi editor**:

    It is also a text editor
    The older, more powerful one
    Comes pre-installed in all Linux systems
    Harder for beginners


üìå Use these commands in the terminal to manage files, navigate folders, and control your Linux system.

**To use terminal command , Press Ctrl + Alt + T**

## üñ•Ô∏è VMware vs VirtualBox ‚Äì Simple Difference

Both **VMware** and **VirtualBox** are **virtualization software**.  
They let you **run another operating system** (like Linux) **inside your current OS** (like Windows), without removing or changing anything.

---

### ‚úÖ What Do They Mean?

| Software     | Meaning                                                                 |
|--------------|-------------------------------------------------------------------------|
| **VMware**   | A professional virtualization tool used for creating and managing VMs. |
| **VirtualBox** | A free, open-source virtualization tool made by Oracle.                |

---

### üîÅ Main Difference :

| Feature             | **VirtualBox**                          | **VMware**                              |
|---------------------|-----------------------------------------|-----------------------------------------|
| Cost                | ‚úÖ Free (Open Source)                   | ‚ö†Ô∏è Some versions are paid (e.g., Workstation Pro) |
| User Friendly       | ‚úÖ Beginner-friendly                    | ‚úÖ Professional features, less beginner-focused |
| Performance         | ‚ö†Ô∏è Good but slightly lower             | üöÄ Generally faster and smoother         |
| OS Support          | ‚úÖ Windows, Linux, macOS                | ‚úÖ Windows, Linux (macOS limited)         |
| Ideal For           | Students, learners, open-source fans   | Professional users, enterprise setups   |

---

### üí° Summary:

> Both let you create **virtual machines (VMs)**.  
> Use **VirtualBox** for learning and free use.  
> Use **VMware** if you want more speed and pro features.

## üì¶ What is an ISO File?

An **ISO file** (also called an **ISO image**) is a **complete copy or digital version of a CD, DVD, or other disk**, stored in a **single file**.  
It contains **all the data, files, and folders** needed to create a full copy of the original disk.

---

### ‚úÖ In Linux, What Is It Used For?

- ISO files are used to **distribute operating systems** like **Ubuntu**, **Fedora**, **Kali**, etc.
- You download the ISO file and then **write it to a USB drive** to install Linux on your system.

---
### üìå Key Points:

| Feature        | Description                                               |
|----------------|-----------------------------------------------------------|
| File Extension | `.iso`                                                    |
| Contains       | Full copy of an OS or disk (bootable installer)           |
| Common Use     | To install Linux, Windows, or other operating systems     |

----

## üñ•Ô∏è What is Bare Metal Installation in Linux?

**Bare Metal Installation** means installing Linux **directly on a computer's hardware** ‚Äî not inside any other operating system or virtual machine.

You are installing Linux on a **fresh or empty computer**, just like installing Windows on a new laptop.

---

### ‚úÖ Why is it called "Bare Metal"?

Because the installation is done **on the actual physical machine** ‚Äî the "bare metal" ‚Äî without any layers like:

- No Windows
- No VirtualBox
- No VMware

---

**üõ†Ô∏è Simple Example: Installing Ubuntu on Bare Metal**

#### üìå Where Bare Metal is Used:

- In **servers** (no need for Windows)
- For **learning real Linux**
- In **offices or companies** that use Linux systems
- When you want **full performance** (no lag from virtual machines)

---

#### üîÅ Difference (Simple Table)

| Feature           | Bare Metal Linux     | Virtual Machine Linux     |
|------------------|----------------------|----------------------------|
| Runs directly on hardware | ‚úÖ Yes           | ‚ùå No (runs inside another OS) |
| Needs Windows?   | ‚ùå No                 | ‚úÖ Yes (as host OS)         |
| Speed            | üöÄ Fast               | üê¢ Slower (shared resources) |
| Good for         | Real use, servers     | Practice, testing          |

---

### üí° Tip:

> If you want to use Linux like a real system (not inside Windows), go for **bare metal installation**. It's faster and gives you full control over the machine.

---

# Training Day :- 03

---
### üíæ What is a **Partitioning Scheme**?

> A **partitioning scheme** is a method used to **organize a hard drive** into parts, so operating systems can manage and access data properly.

---

### üîπ **Why Partitioning is Needed?**

* To **install multiple OS** (e.g., Linux + Windows).
* To **separate system files and personal files**.
* For **better data management and backup**.
* To **improve performance** and **security**.

---

### üß± **Common Partitioning Schemes:**

| Scheme                           | Description                                   | Max Partitions | OS Support            |
| -------------------------------- | --------------------------------------------- | -------------- | --------------------- |
| **MBR** (Master Boot Record)     | Older scheme, supports BIOS booting           | 4 primary      | Windows, Linux        |
| **GPT** (GUID Partition Table)   | Modern, supports UEFI booting and large disks | 128 primary    | Windows, Linux, macOS |
| **LVM** (Logical Volume Manager) | Used in Linux, flexible for resizing          | Dynamic        | Linux only            |

---

### üìå **Example:**

When you install Linux:

* You create a partition for **root (`/`)**
* One for **home (`/home`)**
* One for **swap**

That setup is based on a **Linux partitioning scheme**.

---

## üîê Linux File Permission Commands ‚Äì `chmod`, `chmod 444`, `chmod 644`, `chown`

Linux uses file permissions to control **who can read, write, or execute files and directories**. The `chmod` command allows us to modify these permissions. Every file and directory has **permissions** assigned to three types of users ‚Äî **owner(u)**, **group(g)**, and **others(o)**. These permissions determine whether a user can **read**, **write**, or **execute** the file.

---

### ‚úÖ **1. `chmod` (Change File Permissions)**
To **change file or directory permissions** in Linux for the owner, group, and others.

#### üî∏ **Syntax**:

```bash
chmod [permissions] [file_name]
```
**For example:** chmod + x filename.sh

## üîß `chmod +x filename.sh`

### üìò What Does It Do?
The command `chmod +x filename.sh` is used to **add execute permission** to a file (usually a script like `.sh`), so it can be **run as a program**.

---

### üîç Syntax Breakdown

| Component     | Description                                                  |
| ------------- | ------------------------------------------------------------ |
| `chmod`       | Stands for **Change Mode** ‚Äì used to change file permissions |
| `+x`          | Adds **execute** permission                                  |
| `filename.sh` | The name of the shell script file                            |

---

![alt text](++x.png)

![alt text](+x.png)


### ‚úÖ Purpose

This command makes a file **executable** by the **user, group, and others (by default)**.
You can then run the script directly using:

```bash
./filename.sh
```

Without execute permission, you'll see:

```
bash: ./filename.sh: Permission denied

```
### üí° Pro Tip

To give execute permission **only to the file owner**, use:

```bash
chmod u+x filename.sh
```
This is a safer option when sharing code in teams or on public systems.

---


#### üî¢ **Octal Permission Codes**:

| Number | Symbol | Meaning              |
| ------ | ------ | -------------------- |
| 7      | rwx    | Read, Write, Execute |
| 6      | rw-    | Read, Write          |
| 5      | r-x    | Read, Execute        |
| 4      | r--    | Read only            |
| 0      | ---    | No permissions       |

---

### üß™ **Examples**:

#### üîπ `chmod 444 file.txt`
To make a file **read-only** for everyone (owner, group, and others). Prevents editing or deletion.


```bash
chmod 444 file.txt
```

‚ü∂ `r-- r-- r--`



![alt text](chmod444.png)

![alt text](0.444.png)



#### üîπ `chmod 644 file.txt`

To allow the owner to **read and write**, and **group & others to only read**. Commonly used for text/config files.
üî∏ Now only the owner can edit, while others can only read the file.

```bash
chmod 644 file.txt
```

‚ü∂ `rw- r-- r--`

![alt text](chmod644.png)

![alt text](444.png)

### ‚úÖ **2. `chown` (Change File Owner)** [ASSIGNMENT]

`chown` changes the **owner** or **group** of a file or directory.

**Syntax**:
#### üî∏**change owner**:

```bash
chown [new_owner] [file_name]
```
![alt text](chown.png)

#### üî∏ **Change Owner and Group**:

```bash
chown user:group file.txt
```

‚úÖ **Examples**:

    chown kanika file.txt ‚Üí Changes the owner to kanika

    chown root:admin file.txt ‚Üí Changes owner to root and group to admin
---

### üìé **Check Permissions**:
‚úÖ *Tip*: Use ls -l to view current permissions:

 ```bash
 ls -l file.txt
 ```
---

> üîÅ **Quick Tip**:

> `chmod` = change permissions

> `chown` = change owner

**Point to remember**:

When working with system files, it's often necessary to use **sudo** to **execute chmod** with root privileges.

---
## üîÑ Redirection in Linux

In Linux, **redirection** is a powerful feature used to control **input and output** of commands. It allows you to **save output to files, read from files, or even combine and filter output streams**. This is widely used in scripting and system automation. Redirection operator is ">"

### üîÑ Types of Redirection in Linux

Redirection is used in Linux to control where input comes from and where output or error messages go. It helps in saving outputs to files, reading inputs from files, and managing errors effectively.

--

| **Operator** | **Meaning**                    | **Example**                        | **Result**                                             |
|--------------|--------------------------------|------------------------------------|--------------------------------------------------------|
| `>`          | Output redirection             | `ls > files.txt`                   | Saves output to `files.txt` (overwrites if it exists)  |
| `>>`         | Append output                  | `echo "Hello" >> notes.txt`        | Adds `"Hello"` to end of `notes.txt`                  |
| `<`          | Input redirection              | `wc -l < notes.txt`                | Reads input from `notes.txt` instead of keyboard       |

> üß† **Tip**: Use redirection to log outputs, handle errors gracefully, and automate input/output in shell scripts.

## üì¢ `echo` Command in Linux

The `echo` command is used to **display text, strings, or variables** on the terminal. It‚Äôs one of the most commonly used commands in **shell scripting, logging, and debugging**.

---

### ‚úÖ What Does `echo` Do?

- Prints **text or output** to the screen.
- Displays the value of **environment variables**.
- Writes output to **files using redirection**.
- Supports **escape characters** for formatting.

---

### üìå Syntax:
```bash
echo [option] [string or variable]
````

---

### üîπ Basic Examples

| **Command**          | **Description**            | **Output**           |
| -------------------- | -------------------------- | -------------------- |
| `echo Hello, Linux!` | Print a simple message     | `Hello, Linux!`      |
| `echo $USER`         | Show current username      | `kanika` *(example)* |
| `echo "Home: $HOME"` | Print environment variable | `Home: /home/kanika` |

---

### üîç Formatting Output with `-e` Flag

Use `-e` to interpret special escape characters like new lines or tabs.

| **Escape** | **Meaning** | **Example**                 | **Output**       |
| ---------- | ----------- | --------------------------- | ---------------- |
| `\n`       | New Line    | `echo -e "Line1\nLine2"`    | Line1 <br> Line2 |
| `\t`       | Tab space   | `echo -e "Name:\tKanika"`   | Name:‚ÄÉKanika     |
| `\\`       | Backslash   | `echo -e "Path: C:\\Users"` | Path: C:\Users   |

---

### üí° Pro Tips

* Use `echo` in shell scripts to print progress or debug messages.
* Combine with `>` or `>>` for **logging** outputs to files.
* Works with **variables**, **escape sequences**, and **redirection**.

---

## üö∞ Pipe (`|`) in Linux

In Linux, the **pipe operator (`|`)** is used to **pass the output of one command as input to another**.  
It helps you build powerful command chains by combining simple commands to perform complex tasks.

---

### ‚úÖ What Does a Pipe Do?

- Connects **stdout (output)** of one command to the **stdin (input)** of another.
- Helps create efficient **one-liners** without the need for intermediate files.
- Commonly used in **filtering**, **sorting**, **counting**, and **processing data**.

---

### üìå Syntax:

```bash
command1 | command2
````

‚û° The output of `command1` becomes the input of `command2`.

---
**Example**: sort ‚Äì Sort file content

    cat file.txt | sort

‚úÖ What it does:

  - Reads the content of file.txt
  - Sorts the lines alphabetically using sort

üì§ Output:
Sorted version of the file content, line by line.

### üß† Pro Tips:

* Pipes work **left to right**: output of the left command goes to the right.

* You can **chain multiple pipes**

## Shell Programs

### Program 1 : To display name , age and city

![alt text](nano(name).png)

![alt text](name.png)


### Program 2 : To print multiplication table

![alt text](num.png)

![alt text](nano(num).png)


### Program 3 : To compare two numbers

![alt text](great.png)

![alt text](nano(great).png)

## üì¶ File Compression

File compression is the process of **reducing the size of a file or group of files**. This is done to save storage space or make files easier and faster to transfer over the internet.

**üß† Why Compress Files?**

    ‚úÖ Saves disk space

    ‚úÖ Speeds up file transfer

    ‚úÖ Reduces bandwidth usage

    ‚úÖ Helps in organizing multiple files together (archiving)

### üì¶ File Compression using `gzip`

`gzip` (GNU zip) is a popular **lossless file compression** utility used mainly in **Linux/Unix** systems. It uses the **DEFLATE** algorithm to reduce file size without losing data.

### üîç Purpose of `gzip`

- Reduce file size to save disk space
- Speed up file transfer (especially over networks)
- Commonly used with `tar` for folder compression (`.tar.gz`)

---

### üîß Basic Syntax & Usage

#### üëâ Compress a file

**gzip filename**

 * Compresses filename to filename.gz

 * Output: filename.gz

 * By default, replaces the original file

### üëâ Decompress a file

**gunzip filename.gz**

 * Restores the original `filename`

---

### ‚öôÔ∏è Common `gzip` Options

| Option | Description                              |
| ------ | ---------------------------------------- |
| `-d`   | Decompress (same as `gunzip`)            |
| `-k`   | Keep the original file after compression |
| `-r`   | Compress files recursively (folders)     |
| `-v`   | Verbose ‚Äì show the compression process   |
| `-l`   | Display compression statistics/info      |

### üî∏ Example:

**gzip -kv myfile.txt**

* Compresses `myfile.txt` to `myfile.txt.gz`
* Keeps the original file
* Displays compression details

#### üìÅ Compressing Folders using 'tar' + 'gzip'

Since gzip works on **individual files**, use 'tar' to archive folders first:

#### üëâ Compress a directory:

'tar -czvf archive.tar.gz foldername/'
   
  * c: Create archive

  * z: Compress using gzip

  * v: Verbose

  * f: Output file name

### üëâ Extract .tar.gz archive:

'tar -xzvf archive.tar.gz'

### ‚úÖ Advantages of `gzip`

* Fast and efficient
* Widely available on Linux systems
* Ideal for logs, backups, and file distribution

---

### üìö Bonus Tip (Check Compression Info)

**gzip -l filename.gz**

* Shows original size, compressed size, and compression ratio.

---
## üêß Wildcards ( globbing characters) in Linux

**Wildcards** are special characters used in Linux shell (like Bash) to represent **multiple files or patterns**. They make it easier to **search, match, or operate on files/directories** without typing full names.

### üîë Why Use Wildcards?

| ‚úÖ Benefit                  |     üîç Description                           |
|-----------------------------|-----------------------------------------------|
| **Save time**               | Operate on multiple files with one command    |
| **Flexible file selection** | Match files by patterns (e.g., extensions)    |
| **Automation**              | Useful in scripting and batch operations      |

---
## üêß Wildcards in Linux 

| Wildcard | Meaning                                      | Example Command                        | Matches / Description                               |
|----------|----------------------------------------------|----------------------------------------|-----------------------------------------------------|
| `*`      | Matches **zero or more** characters          | `ls *.txt`                             | Lists all files ending with `.txt`                  |
| `?`      | Matches **exactly one** character            | `rm file?.sh`                          | Deletes files like `file1.sh`, `fileA.sh`          |
| `[ ]`    | Matches **one character** inside brackets    | `cp file[1-3].txt backup/`             | Copies `file1.txt`, `file2.txt`, `file3.txt`       |
| `[^ ]`   | Matches **one character not** in brackets    | `ls file[^0-9].txt`                    | Lists files like `filea.txt`, `file_.txt`          |
| `{}`     | Matches **comma-separated patterns**         | `ls file.{txt,jpg}`                    | Matches `file.txt`, `file.jpg`                     |
| Combined | Use multiple wildcards together              | `ls log_[0-9]*.log`                    | Matches `log_1.log`, `log_22.log`, `log123.log`    |

---

### üö´ Caution

Always **double-check** with `echo` or `ls` before using `rm` with wildcards:

  * 'echo *.txt'  # safe check before deleting
  
  * 'rm *.txt'  # ‚Üê Use only if you're sure

---

### üìö Bonus Tip: Escaping wildcards

If you want to **treat wildcards as normal characters**, use **backslash (`\`)** or quotes:

'echo "*.txt"'      # Prints *.txt
' echo \*.txt'       # Same result

---

## üõ°Ô∏è Escaping Characters in Linux (Shell) [ASSIGNMENT]

In Linux shell (like **bash**), **special characters** (such as `*`, `$`, `"`, `'`, `\`) have **special meanings**. To use them as **normal text**, we need to **escape** them.

## üîë Why Escape Characters?

| Purpose                            | Example                          |
|------------------------------------|----------------------------------|
| Prevent shell from interpreting them | Show `*` as literal asterisk     |
| Include spaces or special chars in file names | Handle `My File.txt` correctly |
| Use variables literally (not expand `$`) | Display `$HOME` as text         |

----

## ‚öôÔ∏è Common Escape Methods

| Method       | Description                                 | Example                     | Output / Use Case                  |
|--------------|---------------------------------------------|-----------------------------|------------------------------------|
| `\` (backslash) | Escapes the next character                  | `echo \$HOME`               | Prints `$HOME` as text             |
| `' '` (single quotes) | Prevents **all** expansion (strong quoting) | `echo '$USER'`             | Prints `$USER` as-is               |
| `" "` (double quotes) | Allows variable expansion but blocks most others | `echo "Hello $USER"`     | Expands `$USER`, treats space as literal |
| `\\`         | Escapes a backslash                          | `echo "\\"`                 | Prints `\`                         |
| `\n`, `\t`   | Escapes for newline and tab in `echo -e`     | `echo -e "Line1\nLine2"`    | Prints on two lines                |

---


## üß™ Examples

### üëâ Prevent wildcard expansion:

* echo \*.txt

üì§ Output: `*.txt`

### üëâ Show a dollar sign without expanding the variable:

* echo \$PATH

üì§ Output: `$PATH`

### üëâ Use quotes to handle spaces:

* touch "My File.txt"

* ls My\ File.txt

---

## üìù Quoting in Linux [ASSIGNMENT] 

In Linux, **quoting** is used to protect **special characters**, **spaces**, and **variables** from being changed or expanded by the shell.

### üìå Why Use Quoting?

| Reason                  | Example                          |
|-------------------------|----------------------------------|
| To protect spaces       | `My File.txt` ‚Üí `"My File.txt"` |
| To stop variable expansion | `$HOME` ‚Üí `'$HOME'`           |
| To safely use symbols   | `$`, `*`, `&`, etc.              |

---

## üîí Types of Quotes

| Quote Type      | Use                     | Example                | Output                     |
|------------------|--------------------------|-------------------------|----------------------------|
| `'single quotes'` | Everything inside stays **exactly the same** | `echo '$HOME'`     | `$HOME` (not expanded)     |
| `"double quotes"` | Expands **variables**, but protects spaces | `echo "My home is $HOME"` | My home is /home/user      |
| `\ backslash`     | Escapes **one special character**     | `echo \$HOME`         | `$HOME` (not expanded)     |

---

## üìö Examples

### üëâ Handling spaces:

* touch "My File.txt"
* ls My\ File.txt


### üëâ Protecting variables:

* echo '$USER'
Output: $USER

* echo "$USER"
Output: your_username

---

> ‚úÖ Tip: Always use quotes when your file names have spaces or special characters.

### üêö What is Shell Scripting?

**Shell scripting** is writing a **series of Linux/Unix commands** in a **text file** (called a script) so they can be **executed together automatically** by the shell.

üß† In Simple Words:

 A **shell script** is like a **recipe** ‚Äî instead of typing each step (command) manually, you write them all in a file and run the file.

 ----

 ## Training Day :- 04

 ### Hardware


## üß† 1. What is Computer Hardware?

Hardware refers to the **physical components** of a computer ‚Äî things you can **see and touch** like CPU, motherboard, RAM, hard disk, ports, etc.

----

## üß† 2. Motherboard ‚Äì Central Hub of the System

The **motherboard** is the main printed circuit board that connects all parts of a computer.

### Basic Structure of a Motherboard

The motherboard is a flatboard made of printed circuits. It has many small parts on it. These parts include slots, sockets, and connectors. Each section of the motherboard has a specific role. **For example**:

  - The **CPU socket** holds the central processing unit (CPU).
  - RAM slots are used for memory modules.
  - Other connectors help attach storage devices and graphics cards.

![alt text](motherboard.png)

### Function of Motherboard

The primary function of a motherboard is to provide a central platform where different components like the processor (CPU), memory modules (RAM), storage drives (HDD/SSD), and expansion cards can be integrated and work together seamlessly. It manages the data, instructions, and power flow between these connected devices.

In simpler terms, you can think of a motherboard as the command centre that allows the different parts of a computer to talk to each other and function as a complete system. It houses vital components like the CPU socket (where the processor is installed), memory slots (for RAM modules), and various ports/interfaces to connect peripherals. The motherboard also distributes power from the power supply unit (PSU) to all the connected components.

### üî∑ Key Components

| Component              | Description                                   |
| ---------------------- | --------------------------------------------- |
| **CPU Socket**         | Holds the processor (brain of computer)       |
| **Memory Slots (RAM)** | Slots for RAM chips (DDR4/DDR5)               |
| **Expansion Slots**    | Add-ons like GPU, sound card, LAN adapter     |
| **Chipset**            | Controls communication between CPU, RAM, I/O  |
| ‚û§ Northbridge          | Connects CPU ‚Üî RAM, Graphics                  |
| ‚û§ Southbridge          | Connects CPU ‚Üî I/O (USB, HDD, audio, etc.)    |
| **BIOS Chip**          | Stores firmware to start the computer         |
| **Power Connectors**   | Supplies power to motherboard from PSU        |
| **Cooling System**     | Includes fan/heat sink to prevent overheating |

> üß† If motherboard is faulty ‚Üí **Replace ‚úî** (Not repair ‚ùå)

---

## ‚ö° 3. Power Supply (SMPS)

* Converts **AC ‚Üî DC** (Switch Mode Power Supply)
* Provides power to all components
* Works with CMOS Battery to:

  * Keep BIOS settings
  * Maintain system clock even when PC is off

---

## ‚öôÔ∏è 4. Booting Process (Power ON to OS)

1. Power goes to ROM
2. **Bootstrap loader** is activated
3. OS is copied from **Hard Disk ‚Üí RAM**
4. CPU starts processing via **registers** and **cache**

> ‚úÖ This startup process is called **Booting**

---

## üìö 5. Memory Hierarchy

| Memory Type      | Speed     | Size     | Use                          |
| ---------------- | --------- | -------- | ---------------------------- |
| **Registers**    | Fastest   | Smallest | CPU instruction handling     |
| **Cache Memory** | Very Fast | Small    | Frequently used data for CPU |
| **RAM**          | Fast      | Medium   | Temporary working memory     |
| **Hard Disk**    | Slow      | Large    | Permanent storage            |

  ![alt text](memory.png)

---

## ‚ö° 6. Cache Memory

* Between CPU and RAM
* Holds **frequently accessed data**
* Reduces speed mismatch
* Saves CPU time by **fetching data faster than RAM**

> ‚úÖ Cache memory is **faster** than RAM
> ‚úÖ Most required data is kept in cache

## üß† Why Do We Need Cache Memory? 

1.  Cache memory reduces the speed gap between the fast CPU and slower main memory (RAM).  
2.  It stores frequently accessed data and instructions for quicker access.  
3.  It minimizes the time the CPU spends waiting for data, improving efficiency.  
4.  It increases overall system performance by reducing memory access delays.  
5.  It decreases the load on main memory by handling repeated data access.  
6.  It speeds up the execution of loops and functions by keeping them readily available.


---

## üíæ 7. RAM Types

| Type     | Full Form   | Feature                            |
| -------- | ----------- | ---------------------------------- |
| **SRAM** | Static RAM  | No refresh, fast, costly           |
| **DRAM** | Dynamic RAM | Needs refresh, slower, widely used |

---

## üíø 8. Storage Devices

| Device           | Use                                 |
| ---------------- | ----------------------------------- |
| **Hard Disk**    | Main permanent storage              |
| **SSD**          | Faster version of HDD (Solid State) |
| **DVD Drive**    | Optical disk reading                |
| **Blu-ray Disc** | New version of DVD (double layer)   |
| **Floppy Disk**  | Very old data storage               |
| **Pen Drive**    | Portable data transfer              |

---

## üåê 9. Input/Output Ports & Interfaces

| Port/Device     | Purpose                                   |
| --------------- | ----------------------------------------- |
| **HDMI Port**   | High-quality video/audio output           |
| **VGA Port**    | Old analog display (needs converter)      |
| **LAN Adapter** | Connects to local network                 |
| **NIC**         | Enables networking/internet               |
| **USB Ports**   | Connects pen drives, keyboard, mouse etc. |
| **Data Cables** | Usually copper wires used for transfer    |

---

## üîß 10. BIOS, Firmware, and Drivers

| Term          | Explanation                                    |
| ------------- | ---------------------------------------------- |
| **BIOS/UEFI** | Firmware stored in ROM; runs before OS starts  |
| **Drivers**   | Utility software that enables hardware working |

---

## üîå 11. Extra Hardware Concepts

| Concept       | Description                                             |
| ------------- | ------------------------------------------------------- |
| **Modem**     | Converts analog ‚Üî digital signals                       |
| **UPS**       | Backup power source (uses battery)                      |
| **SMPS**      | Converts voltage (AC ‚Üî DC)                              |
| **Bootstrap** | Startup instructions in ROM to load OS                  |
| **Registers** | Tiny memory in CPU; faster than RAM, used for execution |

---

## üß† 12. Chipset & Bridges (Detailed)

| Bridge          | Function                                           |
| --------------- | -------------------------------------------------- |
| **Northbridge** | Connects CPU to RAM, GPU, cache                    |
| **Southbridge** | Connects CPU to I/O devices like USB, HDD, network |

üß© These two bridges together form the **motherboard chipset** ‚Äì managing data flow inside the system.



